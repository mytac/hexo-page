{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/phantom/source/css/ie9.css","path":"css/ie9.css","modified":0,"renderable":1},{"_id":"themes/phantom/source/css/ie8.css","path":"css/ie8.css","modified":0,"renderable":1},{"_id":"themes/phantom/source/css/font-awesome.min.css","path":"css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/phantom/source/css/main.css","path":"css/main.css","modified":0,"renderable":1},{"_id":"themes/phantom/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/phantom/source/js/skel.min.js","path":"js/skel.min.js","modified":0,"renderable":1},{"_id":"themes/phantom/source/sass/ie8.scss","path":"sass/ie8.scss","modified":0,"renderable":1},{"_id":"themes/phantom/source/js/util.js","path":"js/util.js","modified":0,"renderable":1},{"_id":"themes/phantom/source/sass/ie9.scss","path":"sass/ie9.scss","modified":0,"renderable":1},{"_id":"themes/phantom/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/phantom/source/sass/main.scss","path":"sass/main.scss","modified":0,"renderable":1},{"_id":"themes/phantom/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/phantom/source/fonts/fontawesome-webfont.woff2","path":"fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/phantom/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/phantom/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/phantom/source/sass/font-awesome.min.css","path":"sass/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/phantom/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/phantom/source/js/ie/html5shiv.js","path":"js/ie/html5shiv.js","modified":0,"renderable":1},{"_id":"themes/phantom/source/js/ie/respond.min.js","path":"js/ie/respond.min.js","modified":0,"renderable":1},{"_id":"themes/phantom/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/phantom/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/phantom/README.md","hash":"44d2145a91a2058f37ed65a0334c948cdc8c30ec","modified":1543314379000},{"_id":"source/_posts/digest-closure.md","hash":"fed5dd86c586edfa243e32282949dda280999fe5","modified":1554283562121},{"_id":"source/_posts/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1542011645115},{"_id":"source/_posts/test.md","hash":"a1d93206cb28bd213baac3b7c978928ea6e3f1ad","modified":1553761525071},{"_id":"source/_posts/react-diff算法详解.md","hash":"7535d2318eb0882f52941a656ab9e5544c3f2e4d","modified":1553762983565},{"_id":"themes/phantom/_config.yml","hash":"2eb83cc0d66a72f9ddcb0d3522623a55e796483d","modified":1553764120079},{"_id":"themes/phantom/languages/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1543314379000},{"_id":"themes/phantom/languages/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1543314379000},{"_id":"themes/phantom/languages/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1543314379000},{"_id":"themes/phantom/languages/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1543314379000},{"_id":"themes/phantom/languages/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1543314379000},{"_id":"themes/phantom/languages/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1543314379000},{"_id":"themes/phantom/languages/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1543314379000},{"_id":"themes/phantom/languages/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1543314379000},{"_id":"themes/phantom/languages/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1543314379000},{"_id":"themes/phantom/layout/page.ejs","hash":"54f11f374dd0903086bd5bf7db507908034a8f28","modified":1543314379000},{"_id":"themes/phantom/layout/post.ejs","hash":"38382e9bbeb6b8d2eafbd53fff2984111f524c1a","modified":1543314379000},{"_id":"themes/phantom/layout/index.ejs","hash":"09022447f0047ca04e14c27e8cdccc763131e9ad","modified":1543314379000},{"_id":"themes/phantom/layout/archive.ejs","hash":"7ab1832ba8a8156a61896e9b618b084771e77124","modified":1543314379000},{"_id":"themes/phantom/layout/layout.ejs","hash":"1cc5d0e68150966bf19e149c5bca86d5d741aebb","modified":1543314379000},{"_id":"themes/phantom/layout/_partial/article-archive.ejs","hash":"a59de36284b5fa1d1ae173ff69a08e20250b29d0","modified":1543314379000},{"_id":"themes/phantom/layout/_partial/after-footer.ejs","hash":"f3c32cb093d8230bba950b08fe6d44a84feb1366","modified":1543314379000},{"_id":"themes/phantom/layout/_partial/comments.ejs","hash":"3fedb75436439d1d6979b7e4d20d48a593e12be4","modified":1554283382006},{"_id":"themes/phantom/layout/_partial/article-full.ejs","hash":"b77037cf191fcdcdc01b14c4ac4e0cb73c9bd1f3","modified":1543314379000},{"_id":"themes/phantom/layout/_partial/article-tags.ejs","hash":"df2a96bad2f411ba2a8216721fc2996fa79bc58b","modified":1543314379000},{"_id":"themes/phantom/layout/_partial/article-index.ejs","hash":"cccb2218f48dfbeef82da6d3417d56c1a1291c60","modified":1543314379000},{"_id":"themes/phantom/layout/_partial/gallery.ejs","hash":"80c3758b90fe6c197b52602456e2c4dcf7167847","modified":1543314379000},{"_id":"themes/phantom/layout/_partial/footer.ejs","hash":"166fa2bc5b6ddcb1c23af2e6dd598f540f594b6f","modified":1543314379000},{"_id":"themes/phantom/layout/_partial/menu.ejs","hash":"1e08ad924dc7c68acc2ff563114d8e8756abf8e3","modified":1543314379000},{"_id":"themes/phantom/layout/_partial/google-analytics.ejs","hash":"4e6e8de9becea5a1636a4dcadcf7a10c06e2426e","modified":1543314379000},{"_id":"themes/phantom/source/css/ie9.css","hash":"1dad1d8872d9d5c8d7013d9e2327c7ce947c5951","modified":1543314379000},{"_id":"themes/phantom/layout/_partial/article-page.ejs","hash":"56bbf11584b920213a9ca811424400cdd767ebf9","modified":1543314379000},{"_id":"themes/phantom/layout/_partial/pagination.ejs","hash":"e093a501c62b8ac7587d6b684f39362955c83490","modified":1543314379000},{"_id":"themes/phantom/source/css/ie8.css","hash":"4f41720ed7a2d4831d248aa591b573383f22263a","modified":1543314379000},{"_id":"themes/phantom/layout/_partial/head.ejs","hash":"5bebcf0387db56f83e35bb3c8e12cb930be8d050","modified":1553680019468},{"_id":"themes/phantom/source/css/font-awesome.min.css","hash":"12d6861075de8e293265ff6ff03b1f3adcb44c76","modified":1543314379000},{"_id":"themes/phantom/source/css/main.css","hash":"47ce4af611e7fd8908b45a2cbc7c6232a4092cc2","modified":1543314379000},{"_id":"themes/phantom/source/js/main.js","hash":"373d6a6b66b774cd548c36ea65f43fe9986a2fec","modified":1543314379000},{"_id":"themes/phantom/source/js/skel.min.js","hash":"14f390065fddc652ca1717aaebf5b44f8de78f9d","modified":1543314379000},{"_id":"themes/phantom/source/sass/ie8.scss","hash":"0119f291fb39e5910a2a663f6fd8ef16f914d4f0","modified":1543314379000},{"_id":"themes/phantom/source/js/util.js","hash":"3ece9010adc07dd3dc27ced0e22e7ac8bcd16e14","modified":1543314379000},{"_id":"themes/phantom/source/sass/ie9.scss","hash":"ead318fa43632d5f6756e59e4c91fc57bfffa8df","modified":1543314379000},{"_id":"themes/phantom/source/images/logo.svg","hash":"6de70d5f1da267250a06423e1fa9c32c0f61b3ed","modified":1543314379000},{"_id":"themes/phantom/source/sass/main.scss","hash":"6ce52c347980c1bd1ccf429656fd61225112fe7f","modified":1543314379000},{"_id":"themes/phantom/source/fonts/FontAwesome.otf","hash":"42c179eef588854b5ec151bcf6a3f58aa8b79b11","modified":1543314379000},{"_id":"themes/phantom/source/fonts/fontawesome-webfont.woff2","hash":"638c652d623280a58144f93e7b552c66d1667a11","modified":1543314379000},{"_id":"themes/phantom/source/fonts/fontawesome-webfont.woff","hash":"4a313eb93b959cc4154c684b915b0a31ddb68d84","modified":1543314379000},{"_id":"themes/phantom/source/js/jquery.min.js","hash":"276c87ff3e1e3155679c318938e74e5c1b76d809","modified":1543314379000},{"_id":"themes/phantom/source/sass/font-awesome.min.css","hash":"12d6861075de8e293265ff6ff03b1f3adcb44c76","modified":1543314379000},{"_id":"themes/phantom/source/fonts/fontawesome-webfont.ttf","hash":"6484f1af6b485d5096b71b344e67f4164c33dd1f","modified":1543314379000},{"_id":"themes/phantom/source/js/ie/html5shiv.js","hash":"6ee35415750b51dd65a6521d1dd91aba3e2ae828","modified":1543314379000},{"_id":"themes/phantom/source/js/ie/respond.min.js","hash":"8e786bcf921518f0c8c46d14a51235af2fb99926","modified":1543314379000},{"_id":"themes/phantom/source/sass/base/_code.scss","hash":"251e8e50689bee360c7132c86f26edee32f7aa1a","modified":1543314379000},{"_id":"themes/phantom/source/sass/components/_archives.scss","hash":"c67d35c13df4ba96780a9db92884113ba20527d7","modified":1543314379000},{"_id":"themes/phantom/source/sass/base/_page.scss","hash":"ad76315b33bc518cde02dcce0bbd4083f826c68c","modified":1543314379000},{"_id":"themes/phantom/source/sass/components/_button.scss","hash":"b0a66782c3c971f27933adbbd9608abed4790011","modified":1543314379000},{"_id":"themes/phantom/source/sass/base/_typography.scss","hash":"42347bd599bf7c8b1825cbf823e9c4218d1efa85","modified":1543314379000},{"_id":"themes/phantom/source/sass/components/_form.scss","hash":"61f8aaf6469ba14b2d3a93ae1c2aceed959a203e","modified":1543314379000},{"_id":"themes/phantom/source/sass/components/_box.scss","hash":"78e0660402876cece2af4d67e6a1ca4a8e259e46","modified":1543314379000},{"_id":"themes/phantom/source/fonts/fontawesome-webfont.eot","hash":"986eed8dca049714e43eeebcb3932741a4bec76d","modified":1543314379000},{"_id":"themes/phantom/source/sass/components/_icon.scss","hash":"e05ce4b4ebf3860b0be710a9092c35289e2da70f","modified":1543314379000},{"_id":"themes/phantom/source/sass/components/_gallery.scss","hash":"a7d7973d8dbe0391a66b10b77d6d0848dbc69596","modified":1543314379000},{"_id":"themes/phantom/source/sass/components/_pagination.scss","hash":"291ae4dfa01d2417d8028aa8c7592de5151f4d9c","modified":1543314379000},{"_id":"themes/phantom/source/sass/components/_image.scss","hash":"10912b920e29c62e1832dc7e99c92d2424612a3e","modified":1543314379000},{"_id":"themes/phantom/source/sass/components/_section.scss","hash":"53cfb6eb05860f34cb2722c0802754d423473e38","modified":1543314379000},{"_id":"themes/phantom/source/sass/components/_list.scss","hash":"3e026ecd8d3ec101f465c2b36b2a5500f8f50e8e","modified":1543314379000},{"_id":"themes/phantom/source/sass/components/_table.scss","hash":"835e25f31f283ab6ed1708f8d7d4c7f055d5307b","modified":1543314379000},{"_id":"themes/phantom/source/sass/components/_tiles.scss","hash":"8dbe1b3aa2d779db3ea798502f92edf1af0a9a04","modified":1543314379000},{"_id":"themes/phantom/source/sass/layout/_main.scss","hash":"9311165edc7106d27d5f09ed443a18242cb27ad0","modified":1543314379000},{"_id":"themes/phantom/source/sass/layout/_header.scss","hash":"b11291785d56a8772a7acfd00d32acb9ecf2b01a","modified":1543314379000},{"_id":"themes/phantom/source/sass/layout/_footer.scss","hash":"86bcd67b4f5abb3d48f4ae333a1b8b1738d2833d","modified":1543314379000},{"_id":"themes/phantom/source/sass/layout/_wrapper.scss","hash":"8a17f3846c73918df2e44ab88bbbd49151f18044","modified":1543314379000},{"_id":"themes/phantom/source/sass/layout/_menu.scss","hash":"44a085becfe39d541b509e42900906b6e361cf40","modified":1543314379000},{"_id":"themes/phantom/source/sass/libs/_functions.scss","hash":"4f1e4e3e65837ef26d6df42487ce0ee6d9a3c4cb","modified":1543314379000},{"_id":"themes/phantom/source/sass/libs/_mixins.scss","hash":"091d0598e9beda606514d7a87d0879ef0558ed40","modified":1543314379000},{"_id":"themes/phantom/source/sass/libs/_vars.scss","hash":"6a38a387a0d8ef6213e06b53418945192ee5c0f4","modified":1543314379000},{"_id":"themes/phantom/source/sass/libs/_skel.scss","hash":"da4ca53bc3308b9f4bf35a1a75958fbfb56b4b90","modified":1543314379000},{"_id":"themes/phantom/source/fonts/fontawesome-webfont.svg","hash":"b06b5c8f67fd632cdc62a33b62ae4f74194131b3","modified":1543314379000},{"_id":"public/2019/03/28/react-diff算法详解/index.html","hash":"097ab48873f10b2bcc0223065516c0aba565d356","modified":1554283446652},{"_id":"public/2019/03/27/test/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1554282981000},{"_id":"public/2018/11/12/hello-world/index.html","hash":"a5517f61a9e6cc182fb9e905361257dc7becaabd","modified":1554283446652},{"_id":"public/categories/test/index.html","hash":"23dbc39b27e54ed625844fb14671adaaf38f2d93","modified":1554282981008},{"_id":"public/archives/index.html","hash":"3c53f4bc44c7e108e95d018d7b7a52775eb2505c","modified":1554283565857},{"_id":"public/archives/2018/index.html","hash":"ea895a674f47f8c42e9515e91ff8ff47895a3b61","modified":1554283565857},{"_id":"public/archives/2018/11/index.html","hash":"96c80ef9e831c3e828cc5db961047fa130e8f120","modified":1554283565868},{"_id":"public/archives/2019/index.html","hash":"3a6db7e513f76101165bdacbc846de461d8a7756","modified":1554283565868},{"_id":"public/archives/2019/03/index.html","hash":"7cc3385012f8f6238d6d08acd7379bc8fd1d03ce","modified":1554283565869},{"_id":"public/index.html","hash":"9394b27bcc9ba32ec0d4e2d3f18d9d4eeaacfe36","modified":1554283565869},{"_id":"public/tags/test/index.html","hash":"23dbc39b27e54ed625844fb14671adaaf38f2d93","modified":1554282981009},{"_id":"public/tags/react/index.html","hash":"928868d1336c01d140e67ba3ee1fd6ff9123c85e","modified":1554282981009},{"_id":"public/2019/04/03/digest-closure/index.html","hash":"7a6fc2ee9f4577f5a62dbf1263f98a1132235ef9","modified":1554283565870},{"_id":"public/archives/2019/04/index.html","hash":"0126dfafe93541bc0e94f0140312f922a91f8a33","modified":1554283565869},{"_id":"public/tags/js/index.html","hash":"eb3f197c910785dd72167abbf722df0c24d84446","modified":1554283565869},{"_id":"public/sass/ie8.scss","hash":"0119f291fb39e5910a2a663f6fd8ef16f914d4f0","modified":1554282981033},{"_id":"public/sass/ie9.scss","hash":"ead318fa43632d5f6756e59e4c91fc57bfffa8df","modified":1554282981033},{"_id":"public/images/logo.svg","hash":"6de70d5f1da267250a06423e1fa9c32c0f61b3ed","modified":1554282981033},{"_id":"public/sass/main.scss","hash":"6ce52c347980c1bd1ccf429656fd61225112fe7f","modified":1554282981033},{"_id":"public/fonts/FontAwesome.otf","hash":"42c179eef588854b5ec151bcf6a3f58aa8b79b11","modified":1554282981036},{"_id":"public/fonts/fontawesome-webfont.woff2","hash":"638c652d623280a58144f93e7b552c66d1667a11","modified":1554282981037},{"_id":"public/fonts/fontawesome-webfont.woff","hash":"4a313eb93b959cc4154c684b915b0a31ddb68d84","modified":1554282981038},{"_id":"public/fonts/fontawesome-webfont.eot","hash":"986eed8dca049714e43eeebcb3932741a4bec76d","modified":1554282981038},{"_id":"public/css/ie9.css","hash":"1dad1d8872d9d5c8d7013d9e2327c7ce947c5951","modified":1554282981050},{"_id":"public/css/ie8.css","hash":"4f41720ed7a2d4831d248aa591b573383f22263a","modified":1554282981050},{"_id":"public/js/main.js","hash":"373d6a6b66b774cd548c36ea65f43fe9986a2fec","modified":1554282981051},{"_id":"public/js/ie/html5shiv.js","hash":"6ee35415750b51dd65a6521d1dd91aba3e2ae828","modified":1554282981051},{"_id":"public/js/ie/respond.min.js","hash":"8e786bcf921518f0c8c46d14a51235af2fb99926","modified":1554282981051},{"_id":"public/fonts/fontawesome-webfont.ttf","hash":"6484f1af6b485d5096b71b344e67f4164c33dd1f","modified":1554282981051},{"_id":"public/js/skel.min.js","hash":"14f390065fddc652ca1717aaebf5b44f8de78f9d","modified":1554282981054},{"_id":"public/js/util.js","hash":"3ece9010adc07dd3dc27ced0e22e7ac8bcd16e14","modified":1554282981054},{"_id":"public/css/font-awesome.min.css","hash":"12d6861075de8e293265ff6ff03b1f3adcb44c76","modified":1554282981059},{"_id":"public/sass/font-awesome.min.css","hash":"12d6861075de8e293265ff6ff03b1f3adcb44c76","modified":1554282981059},{"_id":"public/fonts/fontawesome-webfont.svg","hash":"b06b5c8f67fd632cdc62a33b62ae4f74194131b3","modified":1554282981072},{"_id":"public/css/main.css","hash":"47ce4af611e7fd8908b45a2cbc7c6232a4092cc2","modified":1554282981094},{"_id":"public/js/jquery.min.js","hash":"276c87ff3e1e3155679c318938e74e5c1b76d809","modified":1554282981097},{"_id":"source/_posts/消化闭包.md","hash":"b49e439b715e351a8addd4a44ba347afc590c8d7","modified":1554283436182},{"_id":"public/2019/04/03/消化闭包/index.html","hash":"ebcdcc148a904fc8d81c1e96d54e9e38b39aa7f7","modified":1554283446664}],"Category":[{"name":"test","_id":"cju0zyfba0002xwvpuj1hzm9g"}],"Data":[],"Page":[],"Post":[{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2018-11-12T08:34:05.108Z","updated":"2018-11-12T08:34:05.115Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju0zyfb80001xwvpbshq7q0i","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"react-diff算法详解","date":"2019-03-28T08:27:51.000Z","_content":"## 前言\n本文是我阅读《深入React技术栈》所写的总结笔记。如果您觉得本站的markdown代码高亮不友好，建议您查看：[github原文](https://github.com/mytac/blogs/blob/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/react/react%20diff%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3.md)\n\n`reconciliation`调和，是`react`中最为核心的模块，它指的是将virtual dom树转换成actual dom树所耗费的最少操作。他需要进行`diff`->`patch`这两个过程。`diff`是计算virtual dom 树转换成另一棵树进行的最少操作，而`patch`是将差异更新到真实的`dom`节点。\n## diff\n### tree diff\nreact为了让运行效率更高，tree diff只对树进行同层对比，不去比较跨层的节点。比如，在树A中第一层有一个节点B，想要将他移动到第二层，但并不会直接移动。而是会在第二层创建节点B，接着创建节点B的子节点，创建节点B的子节点的子节点...，然后再把之前第一层的B节点删除。\n\n```html\n<A>         <A>\n<B/>        <C>\n<C/>        <B/>\n</A>   ->   </C>\n            </A>\n```\n\n![demo](https://upload-images.jianshu.io/upload_images/5518628-d60043dbeddfce8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/504/format/webp)\n### component diff\n因为react通过组件化开发，在对比组件差异上也采用上述算法。即，同一层只要出现不是同一类型的组件，就替换该组件的所有子节点。对于同一类型的组件，则通过`shouldComponentUpdate`去判断是否需要通过`diff`进行分析。`shouldComponentUpdate`默认为true。\n### element diff\nelement diff主要是根据`mountIndex`和`lastIndex`进行比较，在确定是否移动 ，`mountIndex`是A节点在旧节点结合中的位置，`lastIndex`指访问过的节点，在旧集合中最右的位置，每次遍历都有可能会更新。\n\n#### 算法描述\n1. 遍历新节点集合\n2. 如果出现旧节点集合中有与当前指针所指新节点A相同的节点，则通过对比节点位置进行判断操作，对比`mountIndex`和`lastIndex`：\n\n    如果`mountIndex>=lastIndex`：不做移动操作。并把`lastIndex`更新为`mountIndex`。\n\n    如果`mountIndex<lastIndex`：移动。\n\n3. 如果新节点集合中有旧节点集合中不存在的节点，添加，更新`lastIndex`。\n4. 最后遍历旧节点集合，如果存在新节点集合上不存在的点，则将其删除。\n\n至于为什么要比较`mountIndex`和`lastIndex`，是因为要保证当前要进行移动操作的节点一定要比`lastIndex`小，一是为了节约性能，二是为了使节点排序更有条理，如果不进行比较，看见有相同的节点就移动，整个队列就乱了套了。\n\n> Tips：React中有提示说，要尽量避免将最后一个节点移动到第一个节点的操作。就是因为在一上来比较的时候，本来只需要将最后一个节点移动到第一个位置这一个操作。但按照`diff`算法的逻辑，`mountIndex`为最大值，所以`lastIndex`也更新为最大值，第一个节点之后的节点都需要进行移动操作。\n\n不太明白的同学可以参考这篇文章->[《React之diff算法》](https://www.jianshu.com/p/3ba0822018cf)，里面有分步图文描述，更便于理解。\n\n#### 差异队列\n在上一小节中，我们已经知道了diff是如何判断哪些节点要移动，哪些节点要删除或新增，这些修改的内容都被加入了差异队列当中。其中这三种节点操作，分别对应三种type：(在这之前通过了flattenChildren方法将子节点扁平化，key值相同的只取最后一个节点)\n```\nINSERT_MARKUP: 旧集合中有不存在的组件类型或节点，需要对组件或节点进行插入操作\n\nMOVE_EXISTING: 源码中要对比prevChild===nextChild，即旧集合中有与新集合完全一样的节点，书中说是类型相同且element是可更新的，复用以前的dom节点。\n\nREMOVE_NODE: 旧组件类型在新集合中也存在，但对应的element不同，不能更新和复用。或者旧组件中存在新集合中不存在的，也需要进行删除操作。\n```\n源码中有三个函数`makeInsertMarkup`，`makeMove`和`makeRemove`，用来返回上述三个操作对象。(大家可以把这里看作`redux`中`action`的概念)。如下，是进行新增操作的对象\n```js\n{\n    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,\n    content: markup,\n    fromIndex: null,\n    fromNode: null,\n    toIndex: toIndex,\n    afterNode: afterNode,\n}\n```\n在遍历的过程中，react不会一发现需要更新的节点就立即更新到真实dom上，而是将所有的上述差异对象，全部放入差异队列中，然后通过patch再将其更新到真实的dom上。\n## patch\npatch是指遍历差异队列依次更新到真实dom上的操作。通过`switch`去匹配差异对象的type，然后进行对应的操作。\n[=>patch源码在这里](https://github.com/facebook/react/blob/v15.0.0/src/renderers/dom/client/utils/DOMChildrenOperations.js)\n## 参考文档\n1. [react源码--renderers/shared/reconciler/ReactMultiChild.js](https://github.com/facebook/react/blob/v15.0.0/src/renderers/shared/reconciler/ReactMultiChild.js)\n2. [React源码之Diff算法](https://segmentfault.com/a/1190000010686582)","source":"_posts/react-diff算法详解.md","raw":"---\ntitle: react-diff算法详解\ndate: 2019-03-28 16:27:51\ntags:\n  - react\n---\n## 前言\n本文是我阅读《深入React技术栈》所写的总结笔记。如果您觉得本站的markdown代码高亮不友好，建议您查看：[github原文](https://github.com/mytac/blogs/blob/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/react/react%20diff%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3.md)\n\n`reconciliation`调和，是`react`中最为核心的模块，它指的是将virtual dom树转换成actual dom树所耗费的最少操作。他需要进行`diff`->`patch`这两个过程。`diff`是计算virtual dom 树转换成另一棵树进行的最少操作，而`patch`是将差异更新到真实的`dom`节点。\n## diff\n### tree diff\nreact为了让运行效率更高，tree diff只对树进行同层对比，不去比较跨层的节点。比如，在树A中第一层有一个节点B，想要将他移动到第二层，但并不会直接移动。而是会在第二层创建节点B，接着创建节点B的子节点，创建节点B的子节点的子节点...，然后再把之前第一层的B节点删除。\n\n```html\n<A>         <A>\n<B/>        <C>\n<C/>        <B/>\n</A>   ->   </C>\n            </A>\n```\n\n![demo](https://upload-images.jianshu.io/upload_images/5518628-d60043dbeddfce8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/504/format/webp)\n### component diff\n因为react通过组件化开发，在对比组件差异上也采用上述算法。即，同一层只要出现不是同一类型的组件，就替换该组件的所有子节点。对于同一类型的组件，则通过`shouldComponentUpdate`去判断是否需要通过`diff`进行分析。`shouldComponentUpdate`默认为true。\n### element diff\nelement diff主要是根据`mountIndex`和`lastIndex`进行比较，在确定是否移动 ，`mountIndex`是A节点在旧节点结合中的位置，`lastIndex`指访问过的节点，在旧集合中最右的位置，每次遍历都有可能会更新。\n\n#### 算法描述\n1. 遍历新节点集合\n2. 如果出现旧节点集合中有与当前指针所指新节点A相同的节点，则通过对比节点位置进行判断操作，对比`mountIndex`和`lastIndex`：\n\n    如果`mountIndex>=lastIndex`：不做移动操作。并把`lastIndex`更新为`mountIndex`。\n\n    如果`mountIndex<lastIndex`：移动。\n\n3. 如果新节点集合中有旧节点集合中不存在的节点，添加，更新`lastIndex`。\n4. 最后遍历旧节点集合，如果存在新节点集合上不存在的点，则将其删除。\n\n至于为什么要比较`mountIndex`和`lastIndex`，是因为要保证当前要进行移动操作的节点一定要比`lastIndex`小，一是为了节约性能，二是为了使节点排序更有条理，如果不进行比较，看见有相同的节点就移动，整个队列就乱了套了。\n\n> Tips：React中有提示说，要尽量避免将最后一个节点移动到第一个节点的操作。就是因为在一上来比较的时候，本来只需要将最后一个节点移动到第一个位置这一个操作。但按照`diff`算法的逻辑，`mountIndex`为最大值，所以`lastIndex`也更新为最大值，第一个节点之后的节点都需要进行移动操作。\n\n不太明白的同学可以参考这篇文章->[《React之diff算法》](https://www.jianshu.com/p/3ba0822018cf)，里面有分步图文描述，更便于理解。\n\n#### 差异队列\n在上一小节中，我们已经知道了diff是如何判断哪些节点要移动，哪些节点要删除或新增，这些修改的内容都被加入了差异队列当中。其中这三种节点操作，分别对应三种type：(在这之前通过了flattenChildren方法将子节点扁平化，key值相同的只取最后一个节点)\n```\nINSERT_MARKUP: 旧集合中有不存在的组件类型或节点，需要对组件或节点进行插入操作\n\nMOVE_EXISTING: 源码中要对比prevChild===nextChild，即旧集合中有与新集合完全一样的节点，书中说是类型相同且element是可更新的，复用以前的dom节点。\n\nREMOVE_NODE: 旧组件类型在新集合中也存在，但对应的element不同，不能更新和复用。或者旧组件中存在新集合中不存在的，也需要进行删除操作。\n```\n源码中有三个函数`makeInsertMarkup`，`makeMove`和`makeRemove`，用来返回上述三个操作对象。(大家可以把这里看作`redux`中`action`的概念)。如下，是进行新增操作的对象\n```js\n{\n    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,\n    content: markup,\n    fromIndex: null,\n    fromNode: null,\n    toIndex: toIndex,\n    afterNode: afterNode,\n}\n```\n在遍历的过程中，react不会一发现需要更新的节点就立即更新到真实dom上，而是将所有的上述差异对象，全部放入差异队列中，然后通过patch再将其更新到真实的dom上。\n## patch\npatch是指遍历差异队列依次更新到真实dom上的操作。通过`switch`去匹配差异对象的type，然后进行对应的操作。\n[=>patch源码在这里](https://github.com/facebook/react/blob/v15.0.0/src/renderers/dom/client/utils/DOMChildrenOperations.js)\n## 参考文档\n1. [react源码--renderers/shared/reconciler/ReactMultiChild.js](https://github.com/facebook/react/blob/v15.0.0/src/renderers/shared/reconciler/ReactMultiChild.js)\n2. [React源码之Diff算法](https://segmentfault.com/a/1190000010686582)","slug":"react-diff算法详解","published":1,"updated":"2019-03-28T08:49:43.565Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju0zyfbc0004xwvpchob6sjz","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文是我阅读《深入React技术栈》所写的总结笔记。如果您觉得本站的markdown代码高亮不友好，建议您查看：<a href=\"https://github.com/mytac/blogs/blob/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/react/react%20diff%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3.md\" target=\"_blank\" rel=\"noopener\">github原文</a></p>\n<p><code>reconciliation</code>调和，是<code>react</code>中最为核心的模块，它指的是将virtual dom树转换成actual dom树所耗费的最少操作。他需要进行<code>diff</code>-&gt;<code>patch</code>这两个过程。<code>diff</code>是计算virtual dom 树转换成另一棵树进行的最少操作，而<code>patch</code>是将差异更新到真实的<code>dom</code>节点。</p>\n<h2 id=\"diff\"><a href=\"#diff\" class=\"headerlink\" title=\"diff\"></a>diff</h2><h3 id=\"tree-diff\"><a href=\"#tree-diff\" class=\"headerlink\" title=\"tree diff\"></a>tree diff</h3><p>react为了让运行效率更高，tree diff只对树进行同层对比，不去比较跨层的节点。比如，在树A中第一层有一个节点B，想要将他移动到第二层，但并不会直接移动。而是会在第二层创建节点B，接着创建节点B的子节点，创建节点B的子节点的子节点…，然后再把之前第一层的B节点删除。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">A</span>&gt;</span>         <span class=\"tag\">&lt;<span class=\"name\">A</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">B</span>/&gt;</span>        <span class=\"tag\">&lt;<span class=\"name\">C</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">C</span>/&gt;</span>        <span class=\"tag\">&lt;<span class=\"name\">B</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">A</span>&gt;</span>   -&gt;   <span class=\"tag\">&lt;/<span class=\"name\">C</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">A</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5518628-d60043dbeddfce8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/504/format/webp\" alt=\"demo\"></p>\n<h3 id=\"component-diff\"><a href=\"#component-diff\" class=\"headerlink\" title=\"component diff\"></a>component diff</h3><p>因为react通过组件化开发，在对比组件差异上也采用上述算法。即，同一层只要出现不是同一类型的组件，就替换该组件的所有子节点。对于同一类型的组件，则通过<code>shouldComponentUpdate</code>去判断是否需要通过<code>diff</code>进行分析。<code>shouldComponentUpdate</code>默认为true。</p>\n<h3 id=\"element-diff\"><a href=\"#element-diff\" class=\"headerlink\" title=\"element diff\"></a>element diff</h3><p>element diff主要是根据<code>mountIndex</code>和<code>lastIndex</code>进行比较，在确定是否移动 ，<code>mountIndex</code>是A节点在旧节点结合中的位置，<code>lastIndex</code>指访问过的节点，在旧集合中最右的位置，每次遍历都有可能会更新。</p>\n<h4 id=\"算法描述\"><a href=\"#算法描述\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ol>\n<li>遍历新节点集合</li>\n<li><p>如果出现旧节点集合中有与当前指针所指新节点A相同的节点，则通过对比节点位置进行判断操作，对比<code>mountIndex</code>和<code>lastIndex</code>：</p>\n<p> 如果<code>mountIndex&gt;=lastIndex</code>：不做移动操作。并把<code>lastIndex</code>更新为<code>mountIndex</code>。</p>\n<p> 如果<code>mountIndex&lt;lastIndex</code>：移动。</p>\n</li>\n<li><p>如果新节点集合中有旧节点集合中不存在的节点，添加，更新<code>lastIndex</code>。</p>\n</li>\n<li>最后遍历旧节点集合，如果存在新节点集合上不存在的点，则将其删除。</li>\n</ol>\n<p>至于为什么要比较<code>mountIndex</code>和<code>lastIndex</code>，是因为要保证当前要进行移动操作的节点一定要比<code>lastIndex</code>小，一是为了节约性能，二是为了使节点排序更有条理，如果不进行比较，看见有相同的节点就移动，整个队列就乱了套了。</p>\n<blockquote>\n<p>Tips：React中有提示说，要尽量避免将最后一个节点移动到第一个节点的操作。就是因为在一上来比较的时候，本来只需要将最后一个节点移动到第一个位置这一个操作。但按照<code>diff</code>算法的逻辑，<code>mountIndex</code>为最大值，所以<code>lastIndex</code>也更新为最大值，第一个节点之后的节点都需要进行移动操作。</p>\n</blockquote>\n<p>不太明白的同学可以参考这篇文章-&gt;<a href=\"https://www.jianshu.com/p/3ba0822018cf\" target=\"_blank\" rel=\"noopener\">《React之diff算法》</a>，里面有分步图文描述，更便于理解。</p>\n<h4 id=\"差异队列\"><a href=\"#差异队列\" class=\"headerlink\" title=\"差异队列\"></a>差异队列</h4><p>在上一小节中，我们已经知道了diff是如何判断哪些节点要移动，哪些节点要删除或新增，这些修改的内容都被加入了差异队列当中。其中这三种节点操作，分别对应三种type：(在这之前通过了flattenChildren方法将子节点扁平化，key值相同的只取最后一个节点)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INSERT_MARKUP: 旧集合中有不存在的组件类型或节点，需要对组件或节点进行插入操作</span><br><span class=\"line\"></span><br><span class=\"line\">MOVE_EXISTING: 源码中要对比prevChild===nextChild，即旧集合中有与新集合完全一样的节点，书中说是类型相同且element是可更新的，复用以前的dom节点。</span><br><span class=\"line\"></span><br><span class=\"line\">REMOVE_NODE: 旧组件类型在新集合中也存在，但对应的element不同，不能更新和复用。或者旧组件中存在新集合中不存在的，也需要进行删除操作。</span><br></pre></td></tr></table></figure></p>\n<p>源码中有三个函数<code>makeInsertMarkup</code>，<code>makeMove</code>和<code>makeRemove</code>，用来返回上述三个操作对象。(大家可以把这里看作<code>redux</code>中<code>action</code>的概念)。如下，是进行新增操作的对象<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,</span><br><span class=\"line\">    content: markup,</span><br><span class=\"line\">    fromIndex: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    fromNode: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    toIndex: toIndex,</span><br><span class=\"line\">    afterNode: afterNode,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在遍历的过程中，react不会一发现需要更新的节点就立即更新到真实dom上，而是将所有的上述差异对象，全部放入差异队列中，然后通过patch再将其更新到真实的dom上。</p>\n<h2 id=\"patch\"><a href=\"#patch\" class=\"headerlink\" title=\"patch\"></a>patch</h2><p>patch是指遍历差异队列依次更新到真实dom上的操作。通过<code>switch</code>去匹配差异对象的type，然后进行对应的操作。<br><a href=\"https://github.com/facebook/react/blob/v15.0.0/src/renderers/dom/client/utils/DOMChildrenOperations.js\" target=\"_blank\" rel=\"noopener\">=&gt;patch源码在这里</a></p>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><ol>\n<li><a href=\"https://github.com/facebook/react/blob/v15.0.0/src/renderers/shared/reconciler/ReactMultiChild.js\" target=\"_blank\" rel=\"noopener\">react源码–renderers/shared/reconciler/ReactMultiChild.js</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000010686582\" target=\"_blank\" rel=\"noopener\">React源码之Diff算法</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文是我阅读《深入React技术栈》所写的总结笔记。如果您觉得本站的markdown代码高亮不友好，建议您查看：<a href=\"https://github.com/mytac/blogs/blob/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/react/react%20diff%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3.md\" target=\"_blank\" rel=\"noopener\">github原文</a></p>\n<p><code>reconciliation</code>调和，是<code>react</code>中最为核心的模块，它指的是将virtual dom树转换成actual dom树所耗费的最少操作。他需要进行<code>diff</code>-&gt;<code>patch</code>这两个过程。<code>diff</code>是计算virtual dom 树转换成另一棵树进行的最少操作，而<code>patch</code>是将差异更新到真实的<code>dom</code>节点。</p>\n<h2 id=\"diff\"><a href=\"#diff\" class=\"headerlink\" title=\"diff\"></a>diff</h2><h3 id=\"tree-diff\"><a href=\"#tree-diff\" class=\"headerlink\" title=\"tree diff\"></a>tree diff</h3><p>react为了让运行效率更高，tree diff只对树进行同层对比，不去比较跨层的节点。比如，在树A中第一层有一个节点B，想要将他移动到第二层，但并不会直接移动。而是会在第二层创建节点B，接着创建节点B的子节点，创建节点B的子节点的子节点…，然后再把之前第一层的B节点删除。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">A</span>&gt;</span>         <span class=\"tag\">&lt;<span class=\"name\">A</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">B</span>/&gt;</span>        <span class=\"tag\">&lt;<span class=\"name\">C</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">C</span>/&gt;</span>        <span class=\"tag\">&lt;<span class=\"name\">B</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">A</span>&gt;</span>   -&gt;   <span class=\"tag\">&lt;/<span class=\"name\">C</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">A</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5518628-d60043dbeddfce8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/504/format/webp\" alt=\"demo\"></p>\n<h3 id=\"component-diff\"><a href=\"#component-diff\" class=\"headerlink\" title=\"component diff\"></a>component diff</h3><p>因为react通过组件化开发，在对比组件差异上也采用上述算法。即，同一层只要出现不是同一类型的组件，就替换该组件的所有子节点。对于同一类型的组件，则通过<code>shouldComponentUpdate</code>去判断是否需要通过<code>diff</code>进行分析。<code>shouldComponentUpdate</code>默认为true。</p>\n<h3 id=\"element-diff\"><a href=\"#element-diff\" class=\"headerlink\" title=\"element diff\"></a>element diff</h3><p>element diff主要是根据<code>mountIndex</code>和<code>lastIndex</code>进行比较，在确定是否移动 ，<code>mountIndex</code>是A节点在旧节点结合中的位置，<code>lastIndex</code>指访问过的节点，在旧集合中最右的位置，每次遍历都有可能会更新。</p>\n<h4 id=\"算法描述\"><a href=\"#算法描述\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ol>\n<li>遍历新节点集合</li>\n<li><p>如果出现旧节点集合中有与当前指针所指新节点A相同的节点，则通过对比节点位置进行判断操作，对比<code>mountIndex</code>和<code>lastIndex</code>：</p>\n<p> 如果<code>mountIndex&gt;=lastIndex</code>：不做移动操作。并把<code>lastIndex</code>更新为<code>mountIndex</code>。</p>\n<p> 如果<code>mountIndex&lt;lastIndex</code>：移动。</p>\n</li>\n<li><p>如果新节点集合中有旧节点集合中不存在的节点，添加，更新<code>lastIndex</code>。</p>\n</li>\n<li>最后遍历旧节点集合，如果存在新节点集合上不存在的点，则将其删除。</li>\n</ol>\n<p>至于为什么要比较<code>mountIndex</code>和<code>lastIndex</code>，是因为要保证当前要进行移动操作的节点一定要比<code>lastIndex</code>小，一是为了节约性能，二是为了使节点排序更有条理，如果不进行比较，看见有相同的节点就移动，整个队列就乱了套了。</p>\n<blockquote>\n<p>Tips：React中有提示说，要尽量避免将最后一个节点移动到第一个节点的操作。就是因为在一上来比较的时候，本来只需要将最后一个节点移动到第一个位置这一个操作。但按照<code>diff</code>算法的逻辑，<code>mountIndex</code>为最大值，所以<code>lastIndex</code>也更新为最大值，第一个节点之后的节点都需要进行移动操作。</p>\n</blockquote>\n<p>不太明白的同学可以参考这篇文章-&gt;<a href=\"https://www.jianshu.com/p/3ba0822018cf\" target=\"_blank\" rel=\"noopener\">《React之diff算法》</a>，里面有分步图文描述，更便于理解。</p>\n<h4 id=\"差异队列\"><a href=\"#差异队列\" class=\"headerlink\" title=\"差异队列\"></a>差异队列</h4><p>在上一小节中，我们已经知道了diff是如何判断哪些节点要移动，哪些节点要删除或新增，这些修改的内容都被加入了差异队列当中。其中这三种节点操作，分别对应三种type：(在这之前通过了flattenChildren方法将子节点扁平化，key值相同的只取最后一个节点)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INSERT_MARKUP: 旧集合中有不存在的组件类型或节点，需要对组件或节点进行插入操作</span><br><span class=\"line\"></span><br><span class=\"line\">MOVE_EXISTING: 源码中要对比prevChild===nextChild，即旧集合中有与新集合完全一样的节点，书中说是类型相同且element是可更新的，复用以前的dom节点。</span><br><span class=\"line\"></span><br><span class=\"line\">REMOVE_NODE: 旧组件类型在新集合中也存在，但对应的element不同，不能更新和复用。或者旧组件中存在新集合中不存在的，也需要进行删除操作。</span><br></pre></td></tr></table></figure></p>\n<p>源码中有三个函数<code>makeInsertMarkup</code>，<code>makeMove</code>和<code>makeRemove</code>，用来返回上述三个操作对象。(大家可以把这里看作<code>redux</code>中<code>action</code>的概念)。如下，是进行新增操作的对象<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,</span><br><span class=\"line\">    content: markup,</span><br><span class=\"line\">    fromIndex: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    fromNode: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    toIndex: toIndex,</span><br><span class=\"line\">    afterNode: afterNode,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在遍历的过程中，react不会一发现需要更新的节点就立即更新到真实dom上，而是将所有的上述差异对象，全部放入差异队列中，然后通过patch再将其更新到真实的dom上。</p>\n<h2 id=\"patch\"><a href=\"#patch\" class=\"headerlink\" title=\"patch\"></a>patch</h2><p>patch是指遍历差异队列依次更新到真实dom上的操作。通过<code>switch</code>去匹配差异对象的type，然后进行对应的操作。<br><a href=\"https://github.com/facebook/react/blob/v15.0.0/src/renderers/dom/client/utils/DOMChildrenOperations.js\" target=\"_blank\" rel=\"noopener\">=&gt;patch源码在这里</a></p>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><ol>\n<li><a href=\"https://github.com/facebook/react/blob/v15.0.0/src/renderers/shared/reconciler/ReactMultiChild.js\" target=\"_blank\" rel=\"noopener\">react源码–renderers/shared/reconciler/ReactMultiChild.js</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000010686582\" target=\"_blank\" rel=\"noopener\">React源码之Diff算法</a></li>\n</ol>\n"},{"title":"消化闭包","date":"2019-04-03T09:14:52.000Z","_content":"## 前言\n之前写过关于闭包的文章，本来以为自己懂了，后来面试时被问到怀疑人生。才明白自己只是觉得自己明白了而已，如果说要将一个东西理解的彻彻底底，就不能“抄书”（我之前就是抄书），而是死抠每一个知识点，一点含糊都会让整个系统崩塌。\n\nok，现在开始死抠。什么是闭包？\n> 闭包就是能够读取其他函数内部变量的函数。例如在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁 ——来自于百度百科\n\n> 闭包是基于词法作用域书写代码时所产生的自然结果。当函数可以记住并访问所在的词法作用域时，就产生了闭包。 ————《你不知道的js（上）》\n\n看不太懂，那就拆开看，什么是词法作用域？\n## 词法作用域\n如图，每个框框中都是一个作用域，引擎在执行`console.log()`时（黄色框中的语句），会从内向外逐个作用域查找变量。在baz中，我们找到了变量c，没有找到a,b，就会往上一层找，bar中有b,c,baz，找到了b，同名变量c被忽略，以此类推，直至所有执行语句都匹配了变量，否则引擎解析失败抛出错误。\n\n![图示](https://wx3.sinaimg.cn/mw690/6f8e0013ly1g1l3a8vgw1j20ls0dg0ts.jpg)\n### 除了词法作用域，还有啥？\n其实作用域包括词法作用域和动态作用域，JavaScript中的作用域是词法作用域（大部分的编程语言也是基于词法作用域）。在上面的图中，我们能清晰地看出来，**每个函数的全部变量都可以在整个函数的范围中使用或复用（嵌套的函数可以使用外部函数的变量）**，这就是函数作用域。那么只有函数才能创建作用域“框框”吗？\n\n我们看下面这几句代码：\n```js\nfor(var b=0;b<3;b++){}\n\nconsole.log('b',b) // 3\n```\n上面的代码中，没有声明任何函数，所以通过var声明的变量b被绑定到外部作用域上，也就是全局。(不了解变量提升的同学，可以看我的这篇文章=>[《详解ES6暂存死区TDZ》](https://www.jianshu.com/p/fe05129e8a4c))，所以上述代码相当于：\n```js\nvar b;\nfor(b=0;b<3;b++){}\nconsole.log('b',b) // 3\n```\n。。。是不是很奇葩，本来只想让变量b在for循环中使用，for循环之后销毁，为啥要让他污染到整个词法作用域嘞？幸运的是，由于人类的探索精神，和几个浏览器爹们对JavaScript这个不健全的儿子的扶持，ES6中有了let和const，作为块作用域的补充。（明明都9012了，我为啥还在写ES6的东西=.=）如下，b在for循环结束时就会被销毁，又由于词法作用域中不存在同名变量，所以这里会报错。\n```js\nfor(let b=0;b<3;b++){}\nconsole.log('b',b) // Uncaught ReferenceError: b is not defined\n```\n我们在理解块作用域的时候，可以将一个`{}`中看成一个块。\n\n### 作用域和上下文到底是不是一个东西?\n答案肯定是\"NO!!\"上文中我们已经明白了，作用域是在函数定义时决定的。上下文其实就是函数中`this`的指向，即当前函数运行时所挂载的对象。\n```js\nconst a=1\nfunction foo(){\n    console.log(this.a)\n}\n\nconst obj={a:2,foo}\n\nfoo() // undefined\nobj.foo() // 2\n```\n这里有个小tips，为啥`const`声明的a，没有像var一样挂载到`window`上呢？其实秘密在这里，[《Javascript闭包：从理论到实现，[[Scopes]]的每一根毛都看得清清楚楚》](https://segmentfault.com/a/1190000015311755?utm_source=tag-newest) （写本章时我也没仔细读这篇文章），const 声明的a其实是在`[[scopes]]`上。\n## 循环和闭包\n### 一道经典面试题\n以下代码为什么与预想的输出不符？\n```js\n// 代码块1\nfor (var i = 0; i < 5; i++) {\n    setTimeout(() => {\n        console.log(i) // 输出5次5\n    }, 0)\n}\n```\n假设A：因为`setTimeout`这块的任务直接进入了事件队列中，所以i循环之后i先变成了5，再执行`setTimeout`，`setTimeout`中的箭头函数会保存对i的引用，所以会打印5个5.\n\n变体一：\n```js\n// 代码块2\nfor (let i = 0; i < 5; i++) {\n    setTimeout(() => {\n        console.log(i) // 输出 0,1,2,3,4\n    }, 0)\n}\n``` \n\n假设结论A成立，那么上式应该也是输出5次5，但是很明显不是，所以结论A并不完全正确。\n\n那我们去掉循环，先写成最简单的异步代码：\n```js\nfunction test(a){\n    setTimeout(function timer(){\n        console.log(a)\n    })\n}\n\ntest('hello')\n```\n执行`test`，`setTimeout`将`timer`函数放入了事件队列，`timer`保留着`test`函数的作用域（在函数定义时创建的），`test`执行完毕，主线程上没有其他任务了，`timer`从事件队列中出队，执行`timer`，执行`console.log(a)`，由于闭包的原因，a依然会保留着之前的引用，输出`'hello'`。\n\n那我们在回到题目中，因为两段代码中的不同只有声明语句，所以我们提出假设B：因为在代码块1中，匿名函数保留着外部词法作用域，i都是在全局作用域上，代码块2中由于存在块作用域，所以它保留着每次循环时i的引用。\n\n变体二：\n```js\n// 代码块3\nfor (var i = 0; i < 5; i++) {\n    ((i) => {\n        setTimeout(function timer() {\n            console.log(i) // 输出 0,1,2,3,4\n        }, 0)\n    })(i)\n}\n```\n使用IIFE传递了变量i给匿名函数，产生了一个新作用域，timer保留着这个作用域链，所以会依次输出。\n\n变体三：\n```js\n// 代码块4\nfor (var i = 0; i < 5; i++) {\n    (() => {\n        setTimeout(function timer() {\n            console.log(i) // 输出 5个5\n        }, 0)\n    })()\n}\n```\n跟变体2的区别为IIFE没有给匿名函数传递i，`timer`保留的作用域链还是全局作用域。\n\n## 完\n希望看完的小伙伴可以彻底明白“闭包”，如果有任何错误请在下方评论区留言，欢迎指正。\n## 推荐文章\n1. [深入理解闭包之前置知识---作用域与词法作用域](https://www.jianshu.com/p/60ca27e185ec)","source":"_posts/digest-closure.md","raw":"---\ntitle: 消化闭包\ndate: 2019-04-03 17:14:52\ntags: \n    - js\n---\n## 前言\n之前写过关于闭包的文章，本来以为自己懂了，后来面试时被问到怀疑人生。才明白自己只是觉得自己明白了而已，如果说要将一个东西理解的彻彻底底，就不能“抄书”（我之前就是抄书），而是死抠每一个知识点，一点含糊都会让整个系统崩塌。\n\nok，现在开始死抠。什么是闭包？\n> 闭包就是能够读取其他函数内部变量的函数。例如在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁 ——来自于百度百科\n\n> 闭包是基于词法作用域书写代码时所产生的自然结果。当函数可以记住并访问所在的词法作用域时，就产生了闭包。 ————《你不知道的js（上）》\n\n看不太懂，那就拆开看，什么是词法作用域？\n## 词法作用域\n如图，每个框框中都是一个作用域，引擎在执行`console.log()`时（黄色框中的语句），会从内向外逐个作用域查找变量。在baz中，我们找到了变量c，没有找到a,b，就会往上一层找，bar中有b,c,baz，找到了b，同名变量c被忽略，以此类推，直至所有执行语句都匹配了变量，否则引擎解析失败抛出错误。\n\n![图示](https://wx3.sinaimg.cn/mw690/6f8e0013ly1g1l3a8vgw1j20ls0dg0ts.jpg)\n### 除了词法作用域，还有啥？\n其实作用域包括词法作用域和动态作用域，JavaScript中的作用域是词法作用域（大部分的编程语言也是基于词法作用域）。在上面的图中，我们能清晰地看出来，**每个函数的全部变量都可以在整个函数的范围中使用或复用（嵌套的函数可以使用外部函数的变量）**，这就是函数作用域。那么只有函数才能创建作用域“框框”吗？\n\n我们看下面这几句代码：\n```js\nfor(var b=0;b<3;b++){}\n\nconsole.log('b',b) // 3\n```\n上面的代码中，没有声明任何函数，所以通过var声明的变量b被绑定到外部作用域上，也就是全局。(不了解变量提升的同学，可以看我的这篇文章=>[《详解ES6暂存死区TDZ》](https://www.jianshu.com/p/fe05129e8a4c))，所以上述代码相当于：\n```js\nvar b;\nfor(b=0;b<3;b++){}\nconsole.log('b',b) // 3\n```\n。。。是不是很奇葩，本来只想让变量b在for循环中使用，for循环之后销毁，为啥要让他污染到整个词法作用域嘞？幸运的是，由于人类的探索精神，和几个浏览器爹们对JavaScript这个不健全的儿子的扶持，ES6中有了let和const，作为块作用域的补充。（明明都9012了，我为啥还在写ES6的东西=.=）如下，b在for循环结束时就会被销毁，又由于词法作用域中不存在同名变量，所以这里会报错。\n```js\nfor(let b=0;b<3;b++){}\nconsole.log('b',b) // Uncaught ReferenceError: b is not defined\n```\n我们在理解块作用域的时候，可以将一个`{}`中看成一个块。\n\n### 作用域和上下文到底是不是一个东西?\n答案肯定是\"NO!!\"上文中我们已经明白了，作用域是在函数定义时决定的。上下文其实就是函数中`this`的指向，即当前函数运行时所挂载的对象。\n```js\nconst a=1\nfunction foo(){\n    console.log(this.a)\n}\n\nconst obj={a:2,foo}\n\nfoo() // undefined\nobj.foo() // 2\n```\n这里有个小tips，为啥`const`声明的a，没有像var一样挂载到`window`上呢？其实秘密在这里，[《Javascript闭包：从理论到实现，[[Scopes]]的每一根毛都看得清清楚楚》](https://segmentfault.com/a/1190000015311755?utm_source=tag-newest) （写本章时我也没仔细读这篇文章），const 声明的a其实是在`[[scopes]]`上。\n## 循环和闭包\n### 一道经典面试题\n以下代码为什么与预想的输出不符？\n```js\n// 代码块1\nfor (var i = 0; i < 5; i++) {\n    setTimeout(() => {\n        console.log(i) // 输出5次5\n    }, 0)\n}\n```\n假设A：因为`setTimeout`这块的任务直接进入了事件队列中，所以i循环之后i先变成了5，再执行`setTimeout`，`setTimeout`中的箭头函数会保存对i的引用，所以会打印5个5.\n\n变体一：\n```js\n// 代码块2\nfor (let i = 0; i < 5; i++) {\n    setTimeout(() => {\n        console.log(i) // 输出 0,1,2,3,4\n    }, 0)\n}\n``` \n\n假设结论A成立，那么上式应该也是输出5次5，但是很明显不是，所以结论A并不完全正确。\n\n那我们去掉循环，先写成最简单的异步代码：\n```js\nfunction test(a){\n    setTimeout(function timer(){\n        console.log(a)\n    })\n}\n\ntest('hello')\n```\n执行`test`，`setTimeout`将`timer`函数放入了事件队列，`timer`保留着`test`函数的作用域（在函数定义时创建的），`test`执行完毕，主线程上没有其他任务了，`timer`从事件队列中出队，执行`timer`，执行`console.log(a)`，由于闭包的原因，a依然会保留着之前的引用，输出`'hello'`。\n\n那我们在回到题目中，因为两段代码中的不同只有声明语句，所以我们提出假设B：因为在代码块1中，匿名函数保留着外部词法作用域，i都是在全局作用域上，代码块2中由于存在块作用域，所以它保留着每次循环时i的引用。\n\n变体二：\n```js\n// 代码块3\nfor (var i = 0; i < 5; i++) {\n    ((i) => {\n        setTimeout(function timer() {\n            console.log(i) // 输出 0,1,2,3,4\n        }, 0)\n    })(i)\n}\n```\n使用IIFE传递了变量i给匿名函数，产生了一个新作用域，timer保留着这个作用域链，所以会依次输出。\n\n变体三：\n```js\n// 代码块4\nfor (var i = 0; i < 5; i++) {\n    (() => {\n        setTimeout(function timer() {\n            console.log(i) // 输出 5个5\n        }, 0)\n    })()\n}\n```\n跟变体2的区别为IIFE没有给匿名函数传递i，`timer`保留的作用域链还是全局作用域。\n\n## 完\n希望看完的小伙伴可以彻底明白“闭包”，如果有任何错误请在下方评论区留言，欢迎指正。\n## 推荐文章\n1. [深入理解闭包之前置知识---作用域与词法作用域](https://www.jianshu.com/p/60ca27e185ec)","slug":"digest-closure","published":1,"updated":"2019-04-03T09:26:02.121Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cju10aymu0000k0vp4fn8ijmi","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>之前写过关于闭包的文章，本来以为自己懂了，后来面试时被问到怀疑人生。才明白自己只是觉得自己明白了而已，如果说要将一个东西理解的彻彻底底，就不能“抄书”（我之前就是抄书），而是死抠每一个知识点，一点含糊都会让整个系统崩塌。</p>\n<p>ok，现在开始死抠。什么是闭包？</p>\n<blockquote>\n<p>闭包就是能够读取其他函数内部变量的函数。例如在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁 ——来自于百度百科</p>\n</blockquote>\n<blockquote>\n<p>闭包是基于词法作用域书写代码时所产生的自然结果。当函数可以记住并访问所在的词法作用域时，就产生了闭包。 ————《你不知道的js（上）》</p>\n</blockquote>\n<p>看不太懂，那就拆开看，什么是词法作用域？</p>\n<h2 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h2><p>如图，每个框框中都是一个作用域，引擎在执行<code>console.log()</code>时（黄色框中的语句），会从内向外逐个作用域查找变量。在baz中，我们找到了变量c，没有找到a,b，就会往上一层找，bar中有b,c,baz，找到了b，同名变量c被忽略，以此类推，直至所有执行语句都匹配了变量，否则引擎解析失败抛出错误。</p>\n<p><img src=\"https://wx3.sinaimg.cn/mw690/6f8e0013ly1g1l3a8vgw1j20ls0dg0ts.jpg\" alt=\"图示\"></p>\n<h3 id=\"除了词法作用域，还有啥？\"><a href=\"#除了词法作用域，还有啥？\" class=\"headerlink\" title=\"除了词法作用域，还有啥？\"></a>除了词法作用域，还有啥？</h3><p>其实作用域包括词法作用域和动态作用域，JavaScript中的作用域是词法作用域（大部分的编程语言也是基于词法作用域）。在上面的图中，我们能清晰地看出来，<strong>每个函数的全部变量都可以在整个函数的范围中使用或复用（嵌套的函数可以使用外部函数的变量）</strong>，这就是函数作用域。那么只有函数才能创建作用域“框框”吗？</p>\n<p>我们看下面这几句代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> b=<span class=\"number\">0</span>;b&lt;<span class=\"number\">3</span>;b++)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'b'</span>,b) <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure></p>\n<p>上面的代码中，没有声明任何函数，所以通过var声明的变量b被绑定到外部作用域上，也就是全局。(不了解变量提升的同学，可以看我的这篇文章=&gt;<a href=\"https://www.jianshu.com/p/fe05129e8a4c\" target=\"_blank\" rel=\"noopener\">《详解ES6暂存死区TDZ》</a>)，所以上述代码相当于：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> b;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(b=<span class=\"number\">0</span>;b&lt;<span class=\"number\">3</span>;b++)&#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'b'</span>,b) <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure></p>\n<p>。。。是不是很奇葩，本来只想让变量b在for循环中使用，for循环之后销毁，为啥要让他污染到整个词法作用域嘞？幸运的是，由于人类的探索精神，和几个浏览器爹们对JavaScript这个不健全的儿子的扶持，ES6中有了let和const，作为块作用域的补充。（明明都9012了，我为啥还在写ES6的东西=.=）如下，b在for循环结束时就会被销毁，又由于词法作用域中不存在同名变量，所以这里会报错。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> b=<span class=\"number\">0</span>;b&lt;<span class=\"number\">3</span>;b++)&#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'b'</span>,b) <span class=\"comment\">// Uncaught ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure></p>\n<p>我们在理解块作用域的时候，可以将一个<code>{}</code>中看成一个块。</p>\n<h3 id=\"作用域和上下文到底是不是一个东西\"><a href=\"#作用域和上下文到底是不是一个东西\" class=\"headerlink\" title=\"作用域和上下文到底是不是一个东西?\"></a>作用域和上下文到底是不是一个东西?</h3><p>答案肯定是”NO!!”上文中我们已经明白了，作用域是在函数定义时决定的。上下文其实就是函数中<code>this</code>的指向，即当前函数运行时所挂载的对象。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a=<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj=&#123;<span class=\"attr\">a</span>:<span class=\"number\">2</span>,foo&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo() <span class=\"comment\">// undefined</span></span><br><span class=\"line\">obj.foo() <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure></p>\n<p>这里有个小tips，为啥<code>const</code>声明的a，没有像var一样挂载到<code>window</code>上呢？其实秘密在这里，[《Javascript闭包：从理论到实现，<a href=\"https://segmentfault.com/a/1190000015311755?utm_source=tag-newest\" target=\"_blank\" rel=\"noopener\">[Scopes]]的每一根毛都看得清清楚楚》</a> （写本章时我也没仔细读这篇文章），const 声明的a其实是在<code>[[scopes]]</code>上。</p>\n<h2 id=\"循环和闭包\"><a href=\"#循环和闭包\" class=\"headerlink\" title=\"循环和闭包\"></a>循环和闭包</h2><h3 id=\"一道经典面试题\"><a href=\"#一道经典面试题\" class=\"headerlink\" title=\"一道经典面试题\"></a>一道经典面试题</h3><p>以下代码为什么与预想的输出不符？<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码块1</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(i) <span class=\"comment\">// 输出5次5</span></span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>假设A：因为<code>setTimeout</code>这块的任务直接进入了事件队列中，所以i循环之后i先变成了5，再执行<code>setTimeout</code>，<code>setTimeout</code>中的箭头函数会保存对i的引用，所以会打印5个5.</p>\n<p>变体一：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码块2</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(i) <span class=\"comment\">// 输出 0,1,2,3,4</span></span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">假设结论A成立，那么上式应该也是输出5次5，但是很明显不是，所以结论A并不完全正确。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">那我们去掉循环，先写成最简单的异步代码：</span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(a)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test(<span class=\"string\">'hello'</span>)</span><br></pre></td></tr></table></figure></p>\n<p>执行<code>test</code>，<code>setTimeout</code>将<code>timer</code>函数放入了事件队列，<code>timer</code>保留着<code>test</code>函数的作用域（在函数定义时创建的），<code>test</code>执行完毕，主线程上没有其他任务了，<code>timer</code>从事件队列中出队，执行<code>timer</code>，执行<code>console.log(a)</code>，由于闭包的原因，a依然会保留着之前的引用，输出<code>&#39;hello&#39;</code>。</p>\n<p>那我们在回到题目中，因为两段代码中的不同只有声明语句，所以我们提出假设B：因为在代码块1中，匿名函数保留着外部词法作用域，i都是在全局作用域上，代码块2中由于存在块作用域，所以它保留着每次循环时i的引用。</p>\n<p>变体二：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码块3</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    (<span class=\"function\">(<span class=\"params\">i</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(i) <span class=\"comment\">// 输出 0,1,2,3,4</span></span><br><span class=\"line\">        &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;)(i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用IIFE传递了变量i给匿名函数，产生了一个新作用域，timer保留着这个作用域链，所以会依次输出。</p>\n<p>变体三：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码块4</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    (<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(i) <span class=\"comment\">// 输出 5个5</span></span><br><span class=\"line\">        &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;)()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>跟变体2的区别为IIFE没有给匿名函数传递i，<code>timer</code>保留的作用域链还是全局作用域。</p>\n<h2 id=\"完\"><a href=\"#完\" class=\"headerlink\" title=\"完\"></a>完</h2><p>希望看完的小伙伴可以彻底明白“闭包”，如果有任何错误请在下方评论区留言，欢迎指正。</p>\n<h2 id=\"推荐文章\"><a href=\"#推荐文章\" class=\"headerlink\" title=\"推荐文章\"></a>推荐文章</h2><ol>\n<li><a href=\"https://www.jianshu.com/p/60ca27e185ec\" target=\"_blank\" rel=\"noopener\">深入理解闭包之前置知识—作用域与词法作用域</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>之前写过关于闭包的文章，本来以为自己懂了，后来面试时被问到怀疑人生。才明白自己只是觉得自己明白了而已，如果说要将一个东西理解的彻彻底底，就不能“抄书”（我之前就是抄书），而是死抠每一个知识点，一点含糊都会让整个系统崩塌。</p>\n<p>ok，现在开始死抠。什么是闭包？</p>\n<blockquote>\n<p>闭包就是能够读取其他函数内部变量的函数。例如在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁 ——来自于百度百科</p>\n</blockquote>\n<blockquote>\n<p>闭包是基于词法作用域书写代码时所产生的自然结果。当函数可以记住并访问所在的词法作用域时，就产生了闭包。 ————《你不知道的js（上）》</p>\n</blockquote>\n<p>看不太懂，那就拆开看，什么是词法作用域？</p>\n<h2 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h2><p>如图，每个框框中都是一个作用域，引擎在执行<code>console.log()</code>时（黄色框中的语句），会从内向外逐个作用域查找变量。在baz中，我们找到了变量c，没有找到a,b，就会往上一层找，bar中有b,c,baz，找到了b，同名变量c被忽略，以此类推，直至所有执行语句都匹配了变量，否则引擎解析失败抛出错误。</p>\n<p><img src=\"https://wx3.sinaimg.cn/mw690/6f8e0013ly1g1l3a8vgw1j20ls0dg0ts.jpg\" alt=\"图示\"></p>\n<h3 id=\"除了词法作用域，还有啥？\"><a href=\"#除了词法作用域，还有啥？\" class=\"headerlink\" title=\"除了词法作用域，还有啥？\"></a>除了词法作用域，还有啥？</h3><p>其实作用域包括词法作用域和动态作用域，JavaScript中的作用域是词法作用域（大部分的编程语言也是基于词法作用域）。在上面的图中，我们能清晰地看出来，<strong>每个函数的全部变量都可以在整个函数的范围中使用或复用（嵌套的函数可以使用外部函数的变量）</strong>，这就是函数作用域。那么只有函数才能创建作用域“框框”吗？</p>\n<p>我们看下面这几句代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> b=<span class=\"number\">0</span>;b&lt;<span class=\"number\">3</span>;b++)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'b'</span>,b) <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure></p>\n<p>上面的代码中，没有声明任何函数，所以通过var声明的变量b被绑定到外部作用域上，也就是全局。(不了解变量提升的同学，可以看我的这篇文章=&gt;<a href=\"https://www.jianshu.com/p/fe05129e8a4c\" target=\"_blank\" rel=\"noopener\">《详解ES6暂存死区TDZ》</a>)，所以上述代码相当于：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> b;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(b=<span class=\"number\">0</span>;b&lt;<span class=\"number\">3</span>;b++)&#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'b'</span>,b) <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure></p>\n<p>。。。是不是很奇葩，本来只想让变量b在for循环中使用，for循环之后销毁，为啥要让他污染到整个词法作用域嘞？幸运的是，由于人类的探索精神，和几个浏览器爹们对JavaScript这个不健全的儿子的扶持，ES6中有了let和const，作为块作用域的补充。（明明都9012了，我为啥还在写ES6的东西=.=）如下，b在for循环结束时就会被销毁，又由于词法作用域中不存在同名变量，所以这里会报错。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> b=<span class=\"number\">0</span>;b&lt;<span class=\"number\">3</span>;b++)&#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'b'</span>,b) <span class=\"comment\">// Uncaught ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure></p>\n<p>我们在理解块作用域的时候，可以将一个<code>{}</code>中看成一个块。</p>\n<h3 id=\"作用域和上下文到底是不是一个东西\"><a href=\"#作用域和上下文到底是不是一个东西\" class=\"headerlink\" title=\"作用域和上下文到底是不是一个东西?\"></a>作用域和上下文到底是不是一个东西?</h3><p>答案肯定是”NO!!”上文中我们已经明白了，作用域是在函数定义时决定的。上下文其实就是函数中<code>this</code>的指向，即当前函数运行时所挂载的对象。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a=<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj=&#123;<span class=\"attr\">a</span>:<span class=\"number\">2</span>,foo&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo() <span class=\"comment\">// undefined</span></span><br><span class=\"line\">obj.foo() <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure></p>\n<p>这里有个小tips，为啥<code>const</code>声明的a，没有像var一样挂载到<code>window</code>上呢？其实秘密在这里，[《Javascript闭包：从理论到实现，<a href=\"https://segmentfault.com/a/1190000015311755?utm_source=tag-newest\" target=\"_blank\" rel=\"noopener\">[Scopes]]的每一根毛都看得清清楚楚》</a> （写本章时我也没仔细读这篇文章），const 声明的a其实是在<code>[[scopes]]</code>上。</p>\n<h2 id=\"循环和闭包\"><a href=\"#循环和闭包\" class=\"headerlink\" title=\"循环和闭包\"></a>循环和闭包</h2><h3 id=\"一道经典面试题\"><a href=\"#一道经典面试题\" class=\"headerlink\" title=\"一道经典面试题\"></a>一道经典面试题</h3><p>以下代码为什么与预想的输出不符？<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码块1</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(i) <span class=\"comment\">// 输出5次5</span></span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>假设A：因为<code>setTimeout</code>这块的任务直接进入了事件队列中，所以i循环之后i先变成了5，再执行<code>setTimeout</code>，<code>setTimeout</code>中的箭头函数会保存对i的引用，所以会打印5个5.</p>\n<p>变体一：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码块2</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(i) <span class=\"comment\">// 输出 0,1,2,3,4</span></span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">假设结论A成立，那么上式应该也是输出5次5，但是很明显不是，所以结论A并不完全正确。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">那我们去掉循环，先写成最简单的异步代码：</span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(a)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test(<span class=\"string\">'hello'</span>)</span><br></pre></td></tr></table></figure></p>\n<p>执行<code>test</code>，<code>setTimeout</code>将<code>timer</code>函数放入了事件队列，<code>timer</code>保留着<code>test</code>函数的作用域（在函数定义时创建的），<code>test</code>执行完毕，主线程上没有其他任务了，<code>timer</code>从事件队列中出队，执行<code>timer</code>，执行<code>console.log(a)</code>，由于闭包的原因，a依然会保留着之前的引用，输出<code>&#39;hello&#39;</code>。</p>\n<p>那我们在回到题目中，因为两段代码中的不同只有声明语句，所以我们提出假设B：因为在代码块1中，匿名函数保留着外部词法作用域，i都是在全局作用域上，代码块2中由于存在块作用域，所以它保留着每次循环时i的引用。</p>\n<p>变体二：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码块3</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    (<span class=\"function\">(<span class=\"params\">i</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(i) <span class=\"comment\">// 输出 0,1,2,3,4</span></span><br><span class=\"line\">        &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;)(i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用IIFE传递了变量i给匿名函数，产生了一个新作用域，timer保留着这个作用域链，所以会依次输出。</p>\n<p>变体三：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码块4</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    (<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(i) <span class=\"comment\">// 输出 5个5</span></span><br><span class=\"line\">        &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;)()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>跟变体2的区别为IIFE没有给匿名函数传递i，<code>timer</code>保留的作用域链还是全局作用域。</p>\n<h2 id=\"完\"><a href=\"#完\" class=\"headerlink\" title=\"完\"></a>完</h2><p>希望看完的小伙伴可以彻底明白“闭包”，如果有任何错误请在下方评论区留言，欢迎指正。</p>\n<h2 id=\"推荐文章\"><a href=\"#推荐文章\" class=\"headerlink\" title=\"推荐文章\"></a>推荐文章</h2><ol>\n<li><a href=\"https://www.jianshu.com/p/60ca27e185ec\" target=\"_blank\" rel=\"noopener\">深入理解闭包之前置知识—作用域与词法作用域</a></li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cju0zyfbc0004xwvpchob6sjz","tag_id":"cju0zyfbf0006xwvpm78lzoj9","_id":"cju0zyfbh000axwvpqxz90ldy"},{"post_id":"cju10aymu0000k0vp4fn8ijmi","tag_id":"cju0zyfbh0009xwvprz0non8l","_id":"cju10ayn00001k0vpmwy1vlka"}],"Tag":[{"name":"test","_id":"cju0zyfbb0003xwvpd4fcunhd"},{"name":"react","_id":"cju0zyfbf0006xwvpm78lzoj9"},{"name":"js","_id":"cju0zyfbh0009xwvprz0non8l"}]}}